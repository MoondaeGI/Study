위쪽 커멘드: 이전에 실행한 커맨드 다시 실행
control + a/e: 줄의 맨 뒤/앞으로 이동
alt + 좌/우: 단어 단위로 뒤앞 움직임
control + c: 입력하던/실행하던 커맨드를 취소
clear: 화면 지우기
tab: 지금 작성중인 커맨드를 자동 완성해줌 

유닉스 디렉토리 구조
-> 트리 구조
-> 디렉토리랑 폴더 위치를 문자열로 표기(경로)
-> 상대 디렉토리 ~

1: pwd
-> 현재 디렉토리를 표시
2: cd
-> 경로를 변경
-> - 이전 경로로 복귀
3: ls
-> 현재 경로 안에 있는 디렉토리 리스트
-> -a: 경로 내의 숨겨진 것을 포함한 모든 디렉토리 리스트를 반환
-> 모든 파일에는 굳이 확장자가 필요 없음
-> -l: 디렉토리와 파일의 자세한 정보를 알려줌
    -> total: 디렉토리 내의 내용물의 공간 차지도
    -> 첫 컬럼의 첫 글자: d, -...
    -> 나머지: 권한 관련
-> 2번째 컬럼: 파일과 연결된 링크 개수
-> 소유자, 
-> 유닉스 파일의 크기
-> 수정 날짜, 크기, 이름

-> 디렉토리에 공백이 있을 경우 -> '', "", 공백 사이에 \ 사용

root 내부의 파일들
1: /bin
-> 커맨드를 동작하게 만들어주는 프로그램이 담겨있는 디렉토리
2: /sbin
-> 관리자용 커맨드
3: /etc
-> 컴퓨터 설정 파일들
4: /home
-> 사용자의 모든 디렉토리를 저장함
5: /usr
-> 사용자에게 필요한 파일을 저장하는 디렉토리
-> /usr 안에도 /bin이 존재


mkdir: 디랙토리를 생성하는 커맨드
touch: 파일에 접근, 없으면 새로 생성하는 커맨드

파일 내용 작성
cli 전용 텍스트 작성 editor: Vim
-> 단축키가 많지만 마우스를 못사용해서 익숙해 질 수 있으면 좋음

vim
1: 일반 모드
-> 일반 모드에서 실행, 다른 모드로 가려면 입력모드를 사용
-> 입력모드로: i, 비주얼 모드로: v,V, 명령 모드로: :, 일반 모드로 돌아가기: esc
2: 입력 모드
3: 비주얼 모드
4: 명령 모드

-> 입력 모드일때 원하는 텍스트 타이핑 가능
텍스트 입력: 입력 모드(i) → 텍스트 입력
텍스트 한 줄 복사: 일반 모드 → 복사하고 싶은 줄에 커서 위치 → yy
텍스트 한 줄 잘라내기: 일반 모드 → 잘라내고 싶은 줄에 커서 위치 → dd
특정 영역 복사: 비주얼 모드(V는 줄 단위, v는 글자 단위) → 복사하고 싶은 영역 커서로 설정 → y
특정 영역 잘라내기: 비주얼 모드(V는 줄 단위, v는 글자 단위) → 잘라내고 싶은 영역 커서로 설정 → d
텍스트 붙여넣기: 일반 모드 → 붙여넣고 싶은 위치에 커서 위치 → p
파일 저장: 명령 모드(:) → w + enter
파일 저장 + vim 종료: 명령 모드(:) → wq + enter
vim 종료 (내용 저장되지 않음): 명령 모드(:) → q! + enter

mv
-> 경로로 위치를 이동, 혹은 이름을 변경
-> 같은 이름의 파일이 있다면 덮어쓰기 당할 수 있음

cp
-> 복사할 대상, 복사할 위치
-> 위치에 대상이 없을 경우 생성
-> 목적지에 똑같은 파일명이 존재할 경우 덮어쓰기 당함
-> 덮어쓰기를 하기 싫다면 i옵션 사용
-> 디렉토리를 복사하기 위해서는 r옵션 사용

rm
-> 파일, 디렉토리를 삭제
-> 삭제 파일, 디렉토리 경로 (복수 허용)
-> 디렉토리를 삭제하기 위해서는 r옵션 사용
-> 삭제하기 전에 확인을 요구하기 위해서는 i옵션 사용
-> 삭제에 묻지도 않고 바로 삭제하는 f옵션 사용

commit 메세지 작성 가이드
1: 커밋 메세지의 제목과 상세 설명 사이에는 한 줄 비워둔다.
2: 메세지 제목 뒤에는 점 찍지 말자
3: 커밋 메세지의 첫번째 문자는 대문자로
4: 커밋 제목은 명령문으로 작성
5: 커밋의 이유, 어떤 문제가 있었는지, 적용한 해결책이 어떠한지
6: 최대한 친절하게 

commit시의 작성 가이드
1: 하나의 커밋에는 하나의 수정사항과 이슈를 해결한 내용을 남긴다
-> 최대한 작은 단위의 변화로 커밋을 실행한다.
2: 커밋을 실시했을때 에러가 발생하지 않아야 한다

git config alias.바꾼 이름 '바꾸고 싶은 명령어'
ex) git config alias.history 'log --pretty=oneline'

head -> 어떤 커밋을 가리킴(보통 가장 최근의 커밋)
-> head의 위치에 따라서 working directory가 달라짐
-> local directory가 최신이라면 head는 최신만을 가리키진 않음

reset -> 과거의 commit으로 working directory로 돌아가는 명령어
-> hard: 커밋 이후의 작업물이 다 사라짐
-> mixed: staging area는 커밋으로 바뀌지만, working directory가 안바뀜
-> soft: repository는 바뀌지만, working directory, staging area가 바뀜
-> 커밋 아이디 대신 HEAD^(HEAD바로 전단계 커밋), HEAD~n(헤드 이전 n번째 커밋)으로 호출 가능

branch
-> 가지로 분리되듯이 다른 버전의 프로젝트를 만들 수 있는 기능
-> branch에서 오버라이딩된 코드는 다른 branch에서는 오버라이딩 되지 않음
-> -d: 삭제, checkout: 다른 branch로 이동, checkout -b: 생성과 동시에 이동

head
-> master가 가리키는 포인터를 가리키는 포인터
-> branch를 새로 만들면 master 외의 새로운 포인터가 생김
-> checkout을 사용해 branch를 변경한다는 것은 head를 해당 branch로 옮기는 것
-> merge를 사용할 경우 해당 branch들을 합쳐서 commit이 되는 것을 말한다

checkout
-> checkout의 대상을 commit id를 직접적으로 가리키면 해당 commit으로 갈 수 있음(detached head)
-> 해당 상태에서 branch생성시, head 위치에 branch가 생성됨
-> detached head를 사용한다면, master branch와 다른 흐름의 branch를 생성 할 수 있음

merge
->merge시 branch를 합친 후 새로운 commit을 실행함
-> 만일 두 포인터가 한 갈래에 존재할 경우 commit을 실행하지 않고 뒤쪽 branch로 포인터가 이동함(fast forward merge)
-> branch가 두갈래로 나뉘었고 그 상태에서 merge commit을 하는 경우(3-way merge)
1: 두 갈래로 갈라지기 전 공통 조상이 되는 커밋
2: 한 브랜치가 가리키는 커밋
3: 다른 브랜치가 가리키는 커밋
-> 셋을 고려해서 실행됨

fetch
-> pull을 하지 않고 가져만 하고 merge하지 않는 명령어
-> 일단 가져와서 살펴본 후 merge하고 싶을때 사용함

blame
-> 어떤 파일의 특정 코드를 누가 작성했는지 찾아내는 명령어
-> 정치질용ㅋㅋ
-> show 사용도 가능

revert
-> 했던 커밋을 취소시키고 다시 커밋시키는 명령어
-> reset은 리모트 리포지토리에 push를 할 수 없음(head가 리모트 레포지토리의 이전 커밋을 가리키기 때문)
-> 다수의 커밋을 취소시킬 경우, 원하는 커밋 이전 커밋부터 원하는 커밋까지

reflog
-> reset을 해도 reset으로 사라진 이전 커밋들이 사라지는 것은 아님
-> 이때까지 헤드가 가리켜온 커밋들을 표시해주는 명령어
-> reset을 사용해도 reflog로 다시 복구 가능

log 
1: --all 
-> 모든 branch의 commit을 볼 수 있는 옵션
2: --graph
-> branch 별로 그래프로 표시해서 어떤 branch의 commit인지 볼 수 있게 해주는 옵션

rebase
-> merge대신 사용가능한 명령어
-> 커밋을 재배치하는 명령어, 명령어의 브랜치로 base로 변경
--continue
-> conflict 발생시 rebase를 계속 실행
-> log가 더 깔끔해짐

stash
-> working directory에서 작업하던 내용을 임시로 저장해줌(stack에 저장)
-> stack을 확인하려면 git stash list 사용
-> stack에서 다시 작업물을 가져오려면 git stash apply를 사용
-> 다른 branch에서 작업했을 경우, 해당 작업을 stack으로 옮기고 다른 branch에 apply를 사용
-> stack이 많이 쌓이기 전에 지워둠(git stash drop)
-> apply와 동시에 drop을 하고 싶으면 pop 사용

cherry-pick
-> 원하는 commit만 가져오는 명령어
-> 자신에게 필요한 commit만 가져와서 현재 branch에 추가하는 명령어

.gitignore
-> 각 프로그램에서 버전 관리가 필요 없는 것들은 github에서 없는 파일처럼 취급해주는 파일
-> 프로그래밍 언어별 .gitignore 참고

