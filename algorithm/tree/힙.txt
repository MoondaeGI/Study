-> 형태 속성: 완전 이진 트리이어야 함
-> 힙 속성: 모든 노드들의 데이터들은 자기 자식 노드의 데이터보다 크거나 같아야 함

-> 완전 이진 트리이기에 리스트(동적 배열)로 구현 가능
-> 트리가 힙속성을 지닐 수 있도록 자식, 부모 데이터와 값을 비교해 크기가 큰 쪽을 부모 데이터로 옮김
    -> 시간 복잡도: O(logN)
    -> leaf 노드를 제외한 모든 노드에 heapify를 사용한다면, 해당 트리는 힙 자료형을 충족하게 된다.
    -> 이경우 시간 복잡도: O(nlongn)

1: 힙 정렬
-> 힙 자료구조로 정렬을 하는 알고리즘
-> root노드와 배열의 마지막 노드와 교체, 마지막 노드를 제외한 트리에서 heapify 실행
-> 반복
-> 내림차순으로 사용하기 위해선 => 힙속성을 역전시킨 후 힙정렬 사용
-> 시간 복잡도: 자료값을 힙구조로 변경(O(nlgn)) + 노드 교체(O(1)) + n번의 heapify(O(nlgn)) = O(nlgn)
    -> 선택/삽입 정렬(O(n^2)보다 좋고, 퀵/합병 정렬과 비슷한 복잡도를 가짐

2: 우선순위 큐
-> 추상 자료형
-> 데이터를 저장 후, 우선순위가 높은 데이터가 먼저 나옴
-> 힙에 데이터를 삽입/삭제가 필요
-> 삽입연산(O(logn)
    -> 가장 마지막 인덱스에 삽입
    -> 부모 노드와 비교 후 힙속성을 확인하며 변경
-> 데이터 추출(O(logn))
    -> root 노드와 마지막 노드를 변경 후 마지막 노드를 변수에 저장
    -> root 노드를 heap속성에 맞게 재정렬 -> 저장된 노드 리턴
-> 동적, 더블리 링크드 리스트 구현 vs 힙 구현
    -> 동적, 링크드 리스트는 삽입에 O(n)이 걸리는 반면, 추출에는 O(1)의 시간 복잡도를 가짐
    -> 삽입할 데이터가 많아질수록 힙이, 빠르게 추출해야 할 수록 동적, 링크드 리스트가 도움됨